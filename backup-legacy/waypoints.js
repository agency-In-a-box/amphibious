// Generated by CoffeeScript 1.6.2
/*!
jQuery Waypoints - v2.0.5
Copyright (c) 2011-2014 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/jquery-waypoints/blob/master/licenses.txt
*/

(() => {
  var __indexOf =
      [].indexOf ||
      function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
          if (i in this && this[i] === item) return i;
        }
        return -1;
      },
    __slice = [].slice;

  ((root, factory) => {
    if (typeof define === 'function' && define.amd) {
      return define('waypoints', ['jquery'], ($) => factory($, root));
    } else {
      return factory(root.jQuery, root);
    }
  })(window, ($, window) => {
    var $w,
      Context,
      Waypoint,
      allWaypoints,
      contextCounter,
      contextKey,
      contexts,
      isTouch,
      jQMethods,
      methods,
      resizeEvent,
      scrollEvent,
      waypointCounter,
      waypointKey,
      wp,
      wps;

    $w = $(window);
    isTouch = __indexOf.call(window, 'ontouchstart') >= 0;
    allWaypoints = {
      horizontal: {},
      vertical: {},
    };
    contextCounter = 1;
    contexts = {};
    contextKey = 'waypoints-context-id';
    resizeEvent = 'resize.waypoints';
    scrollEvent = 'scroll.waypoints';
    waypointCounter = 1;
    waypointKey = 'waypoints-waypoint-ids';
    wp = 'waypoint';
    wps = 'waypoints';
    Context = (() => {
      function Context($element) {
        this.$element = $element;
        this.element = $element[0];
        this.didResize = false;
        this.didScroll = false;
        this.id = 'context' + contextCounter++;
        this.oldScroll = {
          x: $element.scrollLeft(),
          y: $element.scrollTop(),
        };
        this.waypoints = {
          horizontal: {},
          vertical: {},
        };
        this.element[contextKey] = this.id;
        contexts[this.id] = this;
        $element.bind(scrollEvent, () => {
          var scrollHandler;

          if (!(this.didScroll || isTouch)) {
            this.didScroll = true;
            scrollHandler = () => {
              this.doScroll();
              return (this.didScroll = false);
            };
            return window.setTimeout(scrollHandler, $[wps].settings.scrollThrottle);
          }
        });
        $element.bind(resizeEvent, () => {
          var resizeHandler;

          if (!this.didResize) {
            this.didResize = true;
            resizeHandler = () => {
              $[wps]('refresh');
              return (this.didResize = false);
            };
            return window.setTimeout(resizeHandler, $[wps].settings.resizeThrottle);
          }
        });
      }

      Context.prototype.doScroll = function () {
        var axes;

        axes = {
          horizontal: {
            newScroll: this.$element.scrollLeft(),
            oldScroll: this.oldScroll.x,
            forward: 'right',
            backward: 'left',
          },
          vertical: {
            newScroll: this.$element.scrollTop(),
            oldScroll: this.oldScroll.y,
            forward: 'down',
            backward: 'up',
          },
        };
        if (isTouch && (!axes.vertical.oldScroll || !axes.vertical.newScroll)) {
          $[wps]('refresh');
        }
        $.each(axes, (aKey, axis) => {
          var direction, isForward, triggered;

          triggered = [];
          isForward = axis.newScroll > axis.oldScroll;
          direction = isForward ? axis.forward : axis.backward;
          $.each(this.waypoints[aKey], (wKey, waypoint) => {
            var _ref, _ref1;

            if (axis.oldScroll < (_ref = waypoint.offset) && _ref <= axis.newScroll) {
              return triggered.push(waypoint);
            } else if (axis.newScroll < (_ref1 = waypoint.offset) && _ref1 <= axis.oldScroll) {
              return triggered.push(waypoint);
            }
          });
          triggered.sort((a, b) => a.offset - b.offset);
          if (!isForward) {
            triggered.reverse();
          }
          return $.each(triggered, (i, waypoint) => {
            if (waypoint.options.continuous || i === triggered.length - 1) {
              return waypoint.trigger([direction]);
            }
          });
        });
        return (this.oldScroll = {
          x: axes.horizontal.newScroll,
          y: axes.vertical.newScroll,
        });
      };

      Context.prototype.refresh = function () {
        var axes, cOffset, isWin;

        isWin = $.isWindow(this.element);
        cOffset = this.$element.offset();
        this.doScroll();
        axes = {
          horizontal: {
            contextOffset: isWin ? 0 : cOffset.left,
            contextScroll: isWin ? 0 : this.oldScroll.x,
            contextDimension: this.$element.width(),
            oldScroll: this.oldScroll.x,
            forward: 'right',
            backward: 'left',
            offsetProp: 'left',
          },
          vertical: {
            contextOffset: isWin ? 0 : cOffset.top,
            contextScroll: isWin ? 0 : this.oldScroll.y,
            contextDimension: isWin ? $[wps]('viewportHeight') : this.$element.height(),
            oldScroll: this.oldScroll.y,
            forward: 'down',
            backward: 'up',
            offsetProp: 'top',
          },
        };
        return $.each(axes, (aKey, axis) =>
          $.each(this.waypoints[aKey], (i, waypoint) => {
            var adjustment, elementOffset, oldOffset, _ref, _ref1;

            adjustment = waypoint.options.offset;
            oldOffset = waypoint.offset;
            elementOffset = $.isWindow(waypoint.element)
              ? 0
              : waypoint.$element.offset()[axis.offsetProp];
            if ($.isFunction(adjustment)) {
              adjustment = adjustment.apply(waypoint.element);
            } else if (typeof adjustment === 'string') {
              adjustment = Number.parseFloat(adjustment);
              if (waypoint.options.offset.indexOf('%') > -1) {
                adjustment = Math.ceil((axis.contextDimension * adjustment) / 100);
              }
            }
            waypoint.offset = elementOffset - axis.contextOffset + axis.contextScroll - adjustment;
            if ((waypoint.options.onlyOnScroll && oldOffset != null) || !waypoint.enabled) {
              return;
            }
            if (
              oldOffset !== null &&
              oldOffset < (_ref = axis.oldScroll) &&
              _ref <= waypoint.offset
            ) {
              return waypoint.trigger([axis.backward]);
            } else if (
              oldOffset !== null &&
              oldOffset > (_ref1 = axis.oldScroll) &&
              _ref1 >= waypoint.offset
            ) {
              return waypoint.trigger([axis.forward]);
            } else if (oldOffset === null && axis.oldScroll >= waypoint.offset) {
              return waypoint.trigger([axis.forward]);
            }
          }),
        );
      };

      Context.prototype.checkEmpty = function () {
        if (
          $.isEmptyObject(this.waypoints.horizontal) &&
          $.isEmptyObject(this.waypoints.vertical)
        ) {
          this.$element.unbind([resizeEvent, scrollEvent].join(' '));
          return delete contexts[this.id];
        }
      };

      return Context;
    })();
    Waypoint = (() => {
      function Waypoint($element, context, options) {
        var idList, _ref;

        if (options.offset === 'bottom-in-view') {
          options.offset = function () {
            var contextHeight;

            contextHeight = $[wps]('viewportHeight');
            if (!$.isWindow(context.element)) {
              contextHeight = context.$element.height();
            }
            return contextHeight - $(this).outerHeight();
          };
        }
        this.$element = $element;
        this.element = $element[0];
        this.axis = options.horizontal ? 'horizontal' : 'vertical';
        this.callback = options.handler;
        this.context = context;
        this.enabled = options.enabled;
        this.id = 'waypoints' + waypointCounter++;
        this.offset = null;
        this.options = options;
        context.waypoints[this.axis][this.id] = this;
        allWaypoints[this.axis][this.id] = this;
        idList = (_ref = this.element[waypointKey]) != null ? _ref : [];
        idList.push(this.id);
        this.element[waypointKey] = idList;
      }

      Waypoint.prototype.trigger = function (args) {
        if (!this.enabled) {
          return;
        }
        if (this.callback != null) {
          this.callback.apply(this.element, args);
        }
        if (this.options.triggerOnce) {
          return this.destroy();
        }
      };

      Waypoint.prototype.disable = function () {
        return (this.enabled = false);
      };

      Waypoint.prototype.enable = function () {
        this.context.refresh();
        return (this.enabled = true);
      };

      Waypoint.prototype.destroy = function () {
        delete allWaypoints[this.axis][this.id];
        delete this.context.waypoints[this.axis][this.id];
        return this.context.checkEmpty();
      };

      Waypoint.getWaypointsByElement = (element) => {
        var all, ids;

        ids = element[waypointKey];
        if (!ids) {
          return [];
        }
        all = $.extend({}, allWaypoints.horizontal, allWaypoints.vertical);
        return $.map(ids, (id) => all[id]);
      };

      return Waypoint;
    })();
    methods = {
      init: function (f, options) {
        var _ref;

        options = $.extend({}, $.fn[wp].defaults, options);
        if ((_ref = options.handler) == null) {
          options.handler = f;
        }
        this.each(function () {
          var $this, context, contextElement, _ref1;

          $this = $(this);
          contextElement = (_ref1 = options.context) != null ? _ref1 : $.fn[wp].defaults.context;
          if (!$.isWindow(contextElement)) {
            contextElement = $this.closest(contextElement);
          }
          contextElement = $(contextElement);
          context = contexts[contextElement[0][contextKey]];
          if (!context) {
            context = new Context(contextElement);
          }
          return new Waypoint($this, context, options);
        });
        $[wps]('refresh');
        return this;
      },
      disable: function () {
        return methods._invoke.call(this, 'disable');
      },
      enable: function () {
        return methods._invoke.call(this, 'enable');
      },
      destroy: function () {
        return methods._invoke.call(this, 'destroy');
      },
      prev: function (axis, selector) {
        return methods._traverse.call(this, axis, selector, (stack, index, waypoints) => {
          if (index > 0) {
            return stack.push(waypoints[index - 1]);
          }
        });
      },
      next: function (axis, selector) {
        return methods._traverse.call(this, axis, selector, (stack, index, waypoints) => {
          if (index < waypoints.length - 1) {
            return stack.push(waypoints[index + 1]);
          }
        });
      },
      _traverse: function (axis, selector, push) {
        var stack, waypoints;

        if (axis == null) {
          axis = 'vertical';
        }
        if (selector == null) {
          selector = window;
        }
        waypoints = jQMethods.aggregate(selector);
        stack = [];
        this.each(function () {
          var index;

          index = $.inArray(this, waypoints[axis]);
          return push(stack, index, waypoints[axis]);
        });
        return this.pushStack(stack);
      },
      _invoke: function (method) {
        this.each(function () {
          var waypoints;

          waypoints = Waypoint.getWaypointsByElement(this);
          return $.each(waypoints, (i, waypoint) => {
            waypoint[method]();
            return true;
          });
        });
        return this;
      },
    };
    $.fn[wp] = function () {
      var args, method;

      (method = arguments[0]), (args = 2 <= arguments.length ? __slice.call(arguments, 1) : []);
      if (methods[method]) {
        return methods[method].apply(this, args);
      } else if ($.isFunction(method)) {
        return methods.init.apply(this, arguments);
      } else if ($.isPlainObject(method)) {
        return methods.init.apply(this, [null, method]);
      } else if (!method) {
        return $.error('jQuery Waypoints needs a callback function or handler option.');
      } else {
        return $.error('The ' + method + ' method does not exist in jQuery Waypoints.');
      }
    };
    $.fn[wp].defaults = {
      context: window,
      continuous: true,
      enabled: true,
      horizontal: false,
      offset: 0,
      triggerOnce: false,
    };
    jQMethods = {
      refresh: () => $.each(contexts, (i, context) => context.refresh()),
      viewportHeight: () => {
        var _ref;

        return (_ref = window.innerHeight) != null ? _ref : $w.height();
      },
      aggregate: (contextSelector) => {
        var collection, waypoints, _ref;

        collection = allWaypoints;
        if (contextSelector) {
          collection =
            (_ref = contexts[$(contextSelector)[0][contextKey]]) != null ? _ref.waypoints : void 0;
        }
        if (!collection) {
          return [];
        }
        waypoints = {
          horizontal: [],
          vertical: [],
        };
        $.each(waypoints, (axis, arr) => {
          $.each(collection[axis], (key, waypoint) => arr.push(waypoint));
          arr.sort((a, b) => a.offset - b.offset);
          waypoints[axis] = $.map(arr, (waypoint) => waypoint.element);
          return (waypoints[axis] = $.unique(waypoints[axis]));
        });
        return waypoints;
      },
      above: (contextSelector) => {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(
          contextSelector,
          'vertical',
          (context, waypoint) => waypoint.offset <= context.oldScroll.y,
        );
      },
      below: (contextSelector) => {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(
          contextSelector,
          'vertical',
          (context, waypoint) => waypoint.offset > context.oldScroll.y,
        );
      },
      left: (contextSelector) => {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(
          contextSelector,
          'horizontal',
          (context, waypoint) => waypoint.offset <= context.oldScroll.x,
        );
      },
      right: (contextSelector) => {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(
          contextSelector,
          'horizontal',
          (context, waypoint) => waypoint.offset > context.oldScroll.x,
        );
      },
      enable: () => jQMethods._invoke('enable'),
      disable: () => jQMethods._invoke('disable'),
      destroy: () => jQMethods._invoke('destroy'),
      extendFn: (methodName, f) => (methods[methodName] = f),
      _invoke: (method) => {
        var waypoints;

        waypoints = $.extend({}, allWaypoints.vertical, allWaypoints.horizontal);
        return $.each(waypoints, (key, waypoint) => {
          waypoint[method]();
          return true;
        });
      },
      _filter: (selector, axis, test) => {
        var context, waypoints;

        context = contexts[$(selector)[0][contextKey]];
        if (!context) {
          return [];
        }
        waypoints = [];
        $.each(context.waypoints[axis], (i, waypoint) => {
          if (test(context, waypoint)) {
            return waypoints.push(waypoint);
          }
        });
        waypoints.sort((a, b) => a.offset - b.offset);
        return $.map(waypoints, (waypoint) => waypoint.element);
      },
    };
    $[wps] = () => {
      var args, method;

      (method = arguments[0]), (args = 2 <= arguments.length ? __slice.call(arguments, 1) : []);
      if (jQMethods[method]) {
        return jQMethods[method].apply(null, args);
      } else {
        return jQMethods.aggregate.call(null, method);
      }
    };
    $[wps].settings = {
      resizeThrottle: 100,
      scrollThrottle: 30,
    };
    return $w.on('load.waypoints', () => $[wps]('refresh'));
  });
}).call(this);
